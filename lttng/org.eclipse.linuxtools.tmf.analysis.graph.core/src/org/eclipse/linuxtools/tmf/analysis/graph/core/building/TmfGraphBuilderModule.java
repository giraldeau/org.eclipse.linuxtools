/*******************************************************************************
 * Copyright (c) 2013 École Polytechnique de Montréal
 *
 * All rights reserved. This program and the accompanying materials are
 * made available under the terms of the Eclipse Public License v1.0 which
 * accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Geneviève Bastien - Initial API and implementation
 *******************************************************************************/

package org.eclipse.linuxtools.tmf.analysis.graph.core.building;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.linuxtools.tmf.analysis.graph.core.Activator;
import org.eclipse.linuxtools.tmf.analysis.graph.core.base.TmfGraph;
import org.eclipse.linuxtools.tmf.analysis.graph.core.model.TmfModelRegistry;
import org.eclipse.linuxtools.tmf.core.analysis.TmfAbstractAnalysisModule;
import org.eclipse.linuxtools.tmf.core.request.ITmfEventRequest;

/**
 * Base class for all modules building graphs
 *
 * @since 3.0
 */
public abstract class TmfGraphBuilderModule extends TmfAbstractAnalysisModule {

    private TmfGraph fGraph;
    private TmfModelRegistry fRegistry;
    private final List<AnalysisPhase> fPhases = new ArrayList<>();
    private IProgressMonitor fMonitor;
    private ITmfGraphBuildingListener fListener;

    /**
     * Gets the graph provider to build this graph
     *
     * @return The graph provider
     */
    protected abstract ITmfGraphProvider getGraphProvider();

    /**
     * Gets the graph generated by the analysis
     *
     * @return The generated graph
     */
    public TmfGraph getGraph() {
        return fGraph;
    }

    /**
     * Gets the model registry generated while building the graph
     *
     * @return The model registry
     */
    public TmfModelRegistry getModelRegistry() {
        return fRegistry;
    }

    // ------------------------------------------------------------------------
    // TmfAbstractAnalysisModule
    // ------------------------------------------------------------------------

    @Override
    protected boolean executeAnalysis(final IProgressMonitor monitor) {
        fMonitor = (monitor == null ? new NullProgressMonitor() : monitor);
        if (fGraph == null) {
            fRegistry = new TmfModelRegistry();
            final ITmfGraphProvider provider = getGraphProvider();

            /*
             * TODO: This will eventually support multiple backends so we can
             * save the graph on disk, like the state system, but for now, it is
             * just in memory
             */

            createGraph(provider);

        }
        return !fMonitor.isCanceled();
    }

    @Override
    protected void canceling() {
        /* Cancel all ongoing requests */
        boolean hadToCancel = false;
        for (AnalysisPhase phase : fPhases) {
            if (!phase.getRequest().isCompleted()) {
                phase.getRequest().cancel();
                hadToCancel = true;
            }
        }
        if (hadToCancel) {
            fGraph.closeGraph();
        }
    }

    // ------------------------------------------------------------------------
    // Graph creation methods
    // ------------------------------------------------------------------------

    private void createGraph(ITmfGraphProvider provider) {
        if (provider == null) {
            return;
        }

        fGraph = new TmfGraph();
        provider.assignTargetGraph(fGraph);

        build(provider);

    }

    private void build(ITmfGraphProvider provider) {
        for (AnalysisPhase phase : fPhases) {
            if (!phase.getRequest().isCompleted()) {
                phase.getRequest().cancel();
            }
        }
        fPhases.clear();

        List<AnalysisPhase> standardAnalysis = provider.makeAnalysis();
        if (standardAnalysis != null) {
            fPhases.addAll(standardAnalysis);
        }

        fListener = new TmfGraphBuildingListener(fPhases.size(), fMonitor);

        int curr = 0;
        fListener.begin();
        for (AnalysisPhase phase : fPhases) {
            curr++;
            fListener.phase(curr);
            fListener.setTimeRange(provider.getTrace().getStartTime(),
                    provider.getTrace().getEndTime());
            phase.setListener(fListener);
            provider.setCurrentPhase(phase);
            processOnePhase(provider, phase);
        }
        fListener.finished();
    }

    private static void processOnePhase(ITmfGraphProvider provider, AnalysisPhase phase) {
        try {
            ITmfEventRequest request = phase.getRequest();
            provider.getTrace().sendRequest(request);

            request.waitForCompletion();
        } catch (InterruptedException e) {
            Activator.logError("Request interrupted", e); //$NON-NLS-1$
        }

    }

}
