/*******************************************************************************
 * Copyright (c) 2013 École Polytechnique de Montréal
 *
 * All rights reserved. This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License v1.0 which
 * accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Geneviève Bastien and Francis Giraldeau - Initial implementation and API
 *******************************************************************************/

package org.eclipse.linuxtools.tmf.analysis.graph.core.building;

import java.util.List;

import org.eclipse.linuxtools.tmf.analysis.graph.core.base.TmfGraph;
import org.eclipse.linuxtools.tmf.analysis.graph.core.model.TmfSystemModel;
import org.eclipse.linuxtools.tmf.core.event.ITmfEvent;
import org.eclipse.linuxtools.tmf.core.trace.ITmfTrace;

/**
 * This is the interface used to define the execution graph building logic.
 *
 * Usually the graph builder is the piece of the pipeline which converts trace
 * events to an execution graph.
 *
 * @since 3.0
 */
public interface ITmfGraphProvider {

    /**
     * Special state provider version number that will tell the backend to
     * ignore the version check and open an existing file even if the versions
     * don't match.
     */
    final static int IGNORE_PROVIDER_VERSION = -42;

    /**
     * Event handler plugins should provide a version number. This is used to
     * determine if a potential existing file can be re-opened later (if the
     * versions in the file and in the viewer match), or if the file should be
     * rebuilt from scratch (if the versions don't match).
     *
     * @return The version number of the input plugin
     */
    int getVersion();

    /**
     * Get the trace with which this graph builder plugin is associated.
     *
     * @return The associated trace
     */
    ITmfTrace getTrace();

    /**
     * Return the start time of this "graph builder", which is normally the
     * start time of the originating trace (or it can be the time of the first
     * node in the graph).
     *
     * @return The start time
     */
    long getStartTime();

    /**
     * Method for the builder plugin to specify which type of events it expects.
     * This will guarantee that all events it receives via processEvent() are
     * indeed of the given type, so it should be safe to cast to that type.
     *
     * @return The expected Class of the event. Only events of this class (and
     *         valid subclasses) will be handled.
     */
    Class<? extends ITmfEvent> getExpectedEventType();

    /**
     * Assign the target graph where this builder will add new nodes and
     * vertices
     *
     * This needs to be called before .run()!
     *
     * @param graph
     *            Target graph for the state changes generated by this input
     *            plugin
     */
    void assignTargetGraph(TmfGraph graph);

    /**
     * Return the currently assigned target graph.
     *
     * @return Reference to the currently assigned graph, or null if no graph is
     *         assigned yet
     */
    TmfGraph getAssignedGraph();

    /**
     * Send an event to this input plugin for processing. The implementation
     * should check the contents, and call the state-modifying methods of its
     * IStateSystemBuilder object accordingly.
     *
     * @param event
     *            The event (which should be safe to cast to the
     *            expectedEventType) that has to be processed.
     */
    void processEvent(ITmfEvent event);

    /**
     * Indicate to the graph building process that we are done (for now), and
     * that it should close the current graph.
     */
    void dispose();

    /**
     * This function is called before the graph starts building and initializes
     * the system model for this graph. For instance, it will add resource and
     * worker declaration so resources and workers can be created at build time.
     * It can also initialize specific data for specific model classes
     *
     * @param model
     *            The system model
     */
    void initializeModel(TmfSystemModel model);

    /**
     * Gets the collection of analysis phases to do while building this graph.
     * If the analysis phase has handlers (smaller units of work to separate the
     * processing of the event), the handlers should be added in this method.
     *
     * @return A list of analysis phases
     */
    List<AnalysisPhase> makeAnalysis();

    /**
     * Sets the current executing phase
     *
     * @param phase
     *            The phase to execute
     */
    void setCurrentPhase(AnalysisPhase phase);

    /**
     * Gets the current executing phase
     *
     * @return The executing phase
     */
    AnalysisPhase getCurrentPhase();

    /**
     * Performs the necessary actions when the build is cancelled
     */
    void handleCancel();

    /**
     * Callback when graph is complete
     */
    void done();

}
